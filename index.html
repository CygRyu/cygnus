<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/marked@4.0.0/marked.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        success: '#10B981',
                        warning: '#F59E0B',
                        danger: '#EF4444',
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --primary: #5D5CDE;
            --primary-hover: #4B4ACA;
        }

        .slide-in {
            animation: slideIn 0.3s ease-out forwards;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .progress-bar {
            transition: width 0.5s ease;
        }

        .card {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
        }

        .progress-ring {
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen transition-colors duration-200">
    <div class="container mx-auto px-4 py-6 max-w-4xl">
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-primary mb-2">Reading Tracker</h1>
            <p class="text-gray-600 dark:text-gray-400">Track your reading journey, one page at a time.</p>
        </header>

        <div class="grid md:grid-cols-3 gap-6">
            <!-- Stats Panel -->
            <div class="md:col-span-2">
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-5 mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold">Daily Stats</h2>
                        <div class="flex space-x-2">
                            <button id="btn-use-buffer" class="px-3 py-1 bg-primary hover:bg-primary-hover text-white rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-all" disabled>
                                Use Buffer
                            </button>
                            <button id="btn-use-free-pass" class="px-3 py-1 bg-warning hover:bg-amber-600 text-white rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed transition-all" disabled>
                                Use Free Pass
                            </button>
                        </div>
                    </div>

                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="stat-card bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                            <h3 class="text-sm text-gray-500 dark:text-gray-400">Daily Target</h3>
                            <p class="text-2xl font-bold" id="daily-target">10</p>
                        </div>
                        <div class="stat-card bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                            <h3 class="text-sm text-gray-500 dark:text-gray-400">Streak</h3>
                            <p class="text-2xl font-bold"><span id="streak-counter">0</span> / <span id="streak-cycle">10</span></p>
                        </div>
                        <div class="stat-card bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                            <h3 class="text-sm text-gray-500 dark:text-gray-400">Free Pass</h3>
                            <p class="text-2xl font-bold"><span id="free-pass">1</span> / 1</p>
                        </div>
                        <div class="stat-card bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                            <h3 class="text-sm text-gray-500 dark:text-gray-400">Buffer Pages</h3>
                            <p class="text-2xl font-bold"><span id="buffer-pages">0</span> / <span id="max-buffer">20</span></p>
                        </div>
                    </div>

                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <div class="stat-card bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                            <h3 class="text-sm text-gray-500 dark:text-gray-400">Max Daily Buffer</h3>
                            <p class="text-2xl font-bold" id="max-daily-buffer">5</p>
                        </div>
                        <div class="stat-card bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                            <h3 class="text-sm text-gray-500 dark:text-gray-400">Weekly Buffer Uses</h3>
                            <p class="text-2xl font-bold"><span id="weekly-buffer-uses">0</span> / <span id="max-weekly-buffer-uses">2</span></p>
                        </div>
                        <div class="stat-card bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                            <h3 class="text-sm text-gray-500 dark:text-gray-400">Buffer Decay</h3>
                            <p class="text-2xl font-bold"><span id="buffer-decay-countdown">14</span> days</p>
                        </div>
                        <div class="stat-card bg-gray-100 dark:bg-gray-700 p-3 rounded-lg">
                            <h3 class="text-sm text-gray-500 dark:text-gray-400">Completed Streaks</h3>
                            <p class="text-2xl font-bold" id="completed-streaks">0</p>
                        </div>
                    </div>
                </div>

                <!-- Reading Input -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-5 mb-6">
                    <h2 class="text-xl font-semibold mb-4">Log Today's Reading</h2>
                    <form id="reading-form" class="space-y-4">
                        <div>
                            <label for="pages-read" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Pages Read</label>
                            <input type="number" id="pages-read" min="0" class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md text-base bg-white dark:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary" required>
                        </div>
                        <div>
                            <label for="reading-date" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Date</label>
                            <input type="date" id="reading-date" class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md text-base bg-white dark:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary" required>
                        </div>
                        <div>
                            <label for="book-title" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">Book Title (optional)</label>
                            <input type="text" id="book-title" class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md text-base bg-white dark:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary">
                        </div>
                        <button type="submit" class="w-full py-2 px-4 bg-primary hover:bg-primary-hover text-white font-medium rounded-md transition-colors shadow-sm">
                            Submit Reading
                        </button>
                    </form>
                </div>

                <!-- Reading History -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-5">
                    <h2 class="text-xl font-semibold mb-4">Reading History</h2>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                            <thead>
                                <tr>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Date</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Pages</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Book</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Notes</th>
                                </tr>
                            </thead>
                            <tbody id="reading-history" class="divide-y divide-gray-200 dark:divide-gray-700"></tbody>
                        </table>
                        <p id="no-history" class="text-center text-gray-500 dark:text-gray-400 py-4">No reading history yet.</p>
                    </div>
                </div>
            </div>

            <!-- Sidepanel -->
            <div class="md:col-span-1 space-y-6">
                <!-- Streak Progress -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-5">
                    <h2 class="text-xl font-semibold mb-4">Streak Progress</h2>
                    <div class="flex justify-center">
                        <div class="relative w-40 h-40">
                            <svg class="w-full h-full progress-ring">
                                <circle cx="80" cy="80" r="60" fill="transparent" stroke="#e5e7eb" stroke-width="16" />
                                <circle id="streak-progress-ring" cx="80" cy="80" r="60" fill="transparent" stroke="#5D5CDE" stroke-width="16" stroke-dasharray="377" stroke-dashoffset="377" />
                            </svg>
                            <div class="absolute inset-0 flex items-center justify-center flex-col">
                                <span id="streak-progress-text" class="text-3xl font-bold">0%</span>
                                <span class="text-sm text-gray-500 dark:text-gray-400">Complete</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Achievements -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-5">
                    <h2 class="text-xl font-semibold mb-4">Achievements</h2>
                    <div class="space-y-4">
                        <div class="flex justify-between">
                            <span>Completed Streaks:</span>
                            <span id="completed-streaks-badge" class="font-bold">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Completed Prestiges:</span>
                            <span id="completed-prestiges" class="font-bold">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Highest Pages Read:</span>
                            <span id="highest-pages-read" class="font-bold">-</span>
                        </div>
                    </div>
                </div>

                <!-- Prestige Options -->
                <div id="prestige-panel" class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-5 hidden">
                    <h2 class="text-xl font-semibold mb-4">Prestige Options</h2>
                    <p class="text-sm mb-4">You've completed 5 streaks! Choose a permanent bonus:</p>
                    <div class="space-y-3">
                        <button id="prestige-max-daily-buffer" class="w-full py-2 px-4 bg-indigo-100 dark:bg-indigo-900 hover:bg-indigo-200 dark:hover:bg-indigo-800 text-left rounded-md transition-colors text-sm">
                            Max Daily Buffer: +1 page
                        </button>
                        <button id="prestige-max-buffer" class="w-full py-2 px-4 bg-indigo-100 dark:bg-indigo-900 hover:bg-indigo-200 dark:hover:bg-indigo-800 text-left rounded-md transition-colors text-sm">
                            Buffer Pages: +2 pages
                        </button>
                        <button id="prestige-decay-reduction" class="w-full py-2 px-4 bg-indigo-100 dark:bg-indigo-900 hover:bg-indigo-200 dark:hover:bg-indigo-800 text-left rounded-md transition-colors text-sm">
                            Buffer Decay Reduction: -5%
                        </button>
                        <button id="prestige-continue" class="w-full py-2 px-4 bg-amber-100 dark:bg-amber-900 hover:bg-amber-200 dark:hover:bg-amber-800 text-left rounded-md transition-colors text-sm">
                            Continue Without Prestige
                        </button>
                    </div>
                </div>

                <!-- System Rules -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-5">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold">Rules</h2>
                        <button id="toggle-rules" class="text-primary hover:text-primary-hover text-sm font-medium">
                            Show Rules
                        </button>
                    </div>
                    <div id="rules-content" class="hidden prose dark:prose-invert max-w-none text-sm"></div>
                </div>
            </div>
        </div>

        <!-- Notifications -->
        <div id="notification-container" class="fixed bottom-5 right-5 z-50 space-y-3 max-w-sm"></div>

        <!-- Modals -->
        <div id="modal-backdrop" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div id="confirmation-modal" class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4 shadow-xl">
                <h2 id="modal-title" class="text-xl font-bold mb-4">Confirmation</h2>
                <p id="modal-message" class="mb-6">Are you sure?</p>
                <div class="flex justify-end space-x-3">
                    <button id="modal-cancel" class="px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                        Cancel
                    </button>
                    <button id="modal-confirm" class="px-4 py-2 bg-primary hover:bg-primary-hover text-white rounded-md transition-colors">
                        Confirm
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Check for dark mode preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                document.documentElement.classList.add('dark');
            }

            // Rules content
            const rulesContent = `
### **Rules**

#### **Progress**
1. **Starting Target:** {x} begins at 10 pages.
2. **Target Increase:** After completing a streak cycle, {x} increases by 1 page.
3. **Streak Cycle:** A streak cycle lasts **10 days** by default.
4. **Missed Day:**
   - Missing a day resets the streak counter to 0.
   - A **free pass** can be used to avoid resetting the streak. Free passes are replenished (1/1) at the start of each streak cycle.

#### **Buffer System**
1. **Banking Pages:** You can bank extra pages beyond your daily target.
2. **Max. Daily Buffer:** You can bank up to **5 pages** per day (50% of the default target, rounded down).
3. **Weekly Buffer Uses:** You can use your buffer up to **2 times per week**.
4. **Buffer Decay:**
   - After the countdown reaches 0, your buffer decays by **50%** (rounded up).
   - The countdown then resets to **14 days**.
5. **Using the Buffer:**
   - When using the buffer, the total pages read for the day cap at your target. Any excess pages cannot be banked.

---

### **Prestige**

#### **Prestige Condition**
After completing **5 streaks**, you may choose to **prestige** (start a new run) and select **1 permanent bonus** from the following:
- **Max. Daily Buffer:** +1 page (caps at +10).
- **Buffer Pages:** +2 pages (caps at +25).
- **Buffer Decay Reduction:** -5% (caps at -25% total reduction).

#### **Prestige Effects**
- All stats reset to default, except for the chosen permanent bonus.

---

### **Non-Prestige Bonuses**
If you choose **not to prestige**, you gain the following bonuses after every **5 streaks**:
1. **Weekly Buffer Uses:** Increase to **3** (permanent during the current run).
2. **Buffer Decay Countdown:** Extend to **20 days** (permanent during the current run).

These bonuses apply only to the **current run** and do not carry over after prestiging.

---

### **Key Notes**
- **Buffer Pages:** Do not carry over during prestige. All buffer-related stats reset to default.
- **Streak Cycle:** Completing a streak cycle increases your target and replenishes your free pass.
- **Prestige vs. Non-Prestige:** Prestige offers permanent bonuses, while non-prestige provides temporary boosts for the current run.
            `;

            // Initialize state
            let state = {
                dailyTarget: 10,
                streakCounter: 0,
                streakCycle: 10,
                freePass: 1,
                bufferPages: 0,
                maxBuffer: 20,
                maxDailyBuffer: 5,
                weeklyBufferUses: 0,
                maxWeeklyBufferUses: 2,
                bufferDecayCountdown: 14,
                completedStreaks: 0,
                completedPrestiges: 0,
                highestPagesRead: 0,
                lastUpdatedDate: null,
                readingHistory: [],
                weekStartDate: null,
                prestigeBonuses: {
                    maxDailyBufferBonus: 0,
                    maxBufferBonus: 0,
                    decayReductionPercent: 0
                }
            };

            // DOM Elements
            const elements = {
                dailyTarget: document.getElementById('daily-target'),
                streakCounter: document.getElementById('streak-counter'),
                streakCycle: document.getElementById('streak-cycle'),
                freePass: document.getElementById('free-pass'),
                bufferPages: document.getElementById('buffer-pages'),
                maxBuffer: document.getElementById('max-buffer'),
                maxDailyBuffer: document.getElementById('max-daily-buffer'),
                weeklyBufferUses: document.getElementById('weekly-buffer-uses'),
                maxWeeklyBufferUses: document.getElementById('max-weekly-buffer-uses'),
                bufferDecayCountdown: document.getElementById('buffer-decay-countdown'),
                completedStreaks: document.getElementById('completed-streaks'),
                completedStreaksBadge: document.getElementById('completed-streaks-badge'),
                completedPrestiges: document.getElementById('completed-prestiges'),
                highestPagesRead: document.getElementById('highest-pages-read'),
                streakProgressRing: document.getElementById('streak-progress-ring'),
                streakProgressText: document.getElementById('streak-progress-text'),
                btnUseBuffer: document.getElementById('btn-use-buffer'),
                btnUseFreePass: document.getElementById('btn-use-free-pass'),
                readingForm: document.getElementById('reading-form'),
                pagesReadInput: document.getElementById('pages-read'),
                readingDateInput: document.getElementById('reading-date'),
                bookTitleInput: document.getElementById('book-title'),
                readingHistory: document.getElementById('reading-history'),
                noHistory: document.getElementById('no-history'),
                rulesContent: document.getElementById('rules-content'),
                toggleRules: document.getElementById('toggle-rules'),
                prestigePanel: document.getElementById('prestige-panel'),
                modalBackdrop: document.getElementById('modal-backdrop'),
                confirmationModal: document.getElementById('confirmation-modal'),
                modalTitle: document.getElementById('modal-title'),
                modalMessage: document.getElementById('modal-message'),
                modalConfirm: document.getElementById('modal-confirm'),
                modalCancel: document.getElementById('modal-cancel'),
                notificationContainer: document.getElementById('notification-container')
            };

            // Handle toggle rules
            elements.toggleRules.addEventListener('click', function() {
                if (elements.rulesContent.classList.contains('hidden')) {
                    elements.rulesContent.classList.remove('hidden');
                    elements.toggleRules.textContent = 'Hide Rules';
                    elements.rulesContent.innerHTML = marked.parse(rulesContent);
                } else {
                    elements.rulesContent.classList.add('hidden');
                    elements.toggleRules.textContent = 'Show Rules';
                }
            });

            // Set today's date as default
            const today = new Date();
            const formattedDate = formatDateForInput(today);
            elements.readingDateInput.value = formattedDate;
            elements.readingDateInput.max = formattedDate; // Prevent future dates

            // Load data from session storage
            loadState();

            // Check if a day has passed since last update
            checkDayChange();

            // Update UI
            updateUI();

            // Event Listeners
            elements.readingForm.addEventListener('submit', handleReadingSubmit);
            elements.btnUseBuffer.addEventListener('click', handleUseBuffer);
            elements.btnUseFreePass.addEventListener('click', handleUseFreePass);
            
            // Prestige buttons
            document.getElementById('prestige-max-daily-buffer').addEventListener('click', () => handlePrestige('maxDailyBuffer'));
            document.getElementById('prestige-max-buffer').addEventListener('click', () => handlePrestige('maxBuffer'));
            document.getElementById('prestige-decay-reduction').addEventListener('click', () => handlePrestige('decayReduction'));
            document.getElementById('prestige-continue').addEventListener('click', handleContinueWithoutPrestige);

            // Cancel button in modal
            elements.modalCancel.addEventListener('click', hideModal);
            
            // Functions

            function loadState() {
                try {
                    // If supported, try to load from storage
                    const savedState = sessionStorage.getItem('readingTrackerState');
                    if (savedState) {
                        state = JSON.parse(savedState);
                    }
                } catch (error) {
                    console.error('Error loading state:', error);
                    showNotification('Error loading your data. Starting with default settings.', 'error');
                }
            }

            function saveState() {
                try {
                    // Save state to storage
                    sessionStorage.setItem('readingTrackerState', JSON.stringify(state));
                } catch (error) {
                    console.error('Error saving state:', error);
                    showNotification('Error saving your data.', 'error');
                }
            }

            function updateUI() {
                // Update all UI elements based on current state
                elements.dailyTarget.textContent = state.dailyTarget;
                elements.streakCounter.textContent = state.streakCounter;
                elements.streakCycle.textContent = state.streakCycle;
                elements.freePass.textContent = state.freePass;
                elements.bufferPages.textContent = state.bufferPages;
                elements.maxBuffer.textContent = state.maxBuffer;
                elements.maxDailyBuffer.textContent = state.maxDailyBuffer;
                elements.weeklyBufferUses.textContent = state.weeklyBufferUses;
                elements.maxWeeklyBufferUses.textContent = state.maxWeeklyBufferUses;
                elements.bufferDecayCountdown.textContent = state.bufferDecayCountdown;
                elements.completedStreaks.textContent = state.completedStreaks;
                elements.completedStreaksBadge.textContent = state.completedStreaks;
                elements.completedPrestiges.textContent = state.completedPrestiges;
                elements.highestPagesRead.textContent = state.highestPagesRead > 0 ? state.highestPagesRead : '-';

                // Update streak progress ring
                const progress = (state.streakCounter / state.streakCycle) * 100;
                const circumference = 2 * Math.PI * 60;
                const offset = circumference - (progress / 100) * circumference;
                elements.streakProgressRing.style.strokeDasharray = `${circumference} ${circumference}`;
                elements.streakProgressRing.style.strokeDashoffset = offset;
                elements.streakProgressText.textContent = `${Math.round(progress)}%`;

                // Update button states
                updateButtonStates();

                // Update reading history
                updateReadingHistory();

                // Check if prestige is available
                checkPrestigeAvailability();
            }

            function updateButtonStates() {
                // Update buffer button state
                const canUseBuffer = state.bufferPages > 0 && state.weeklyBufferUses < state.maxWeeklyBufferUses;
                elements.btnUseBuffer.disabled = !canUseBuffer;
                
                // Update free pass button state
                elements.btnUseFreePass.disabled = state.freePass <= 0;
                
                // Show/hide appropriate button based on streak status
                const today = new Date().toISOString().split('T')[0];
                const hasEntryForToday = state.readingHistory.some(entry => entry.date === today);
                
                // Show/hide both buttons if user hasn't logged today's reading yet
                elements.btnUseBuffer.style.display = hasEntryForToday ? 'none' : 'block';
                elements.btnUseFreePass.style.display = hasEntryForToday ? 'none' : 'block';
            }

            function updateReadingHistory() {
                if (state.readingHistory.length === 0) {
                    elements.noHistory.style.display = 'block';
                    return;
                }

                elements.noHistory.style.display = 'none';
                elements.readingHistory.innerHTML = '';

                // Show last 10 entries (most recent first)
                const sortedHistory = [...state.readingHistory].sort((a, b) => 
                    new Date(b.date) - new Date(a.date)
                ).slice(0, 10);

                sortedHistory.forEach(entry => {
                    const row = document.createElement('tr');
                    
                    const dateCell = document.createElement('td');
                    dateCell.className = 'px-6 py-4 whitespace-nowrap';
                    dateCell.textContent = formatDate(entry.date);
                    
                    const pagesCell = document.createElement('td');
                    pagesCell.className = 'px-6 py-4 whitespace-nowrap';
                    pagesCell.textContent = entry.pagesRead;
                    
                    const bookCell = document.createElement('td');
                    bookCell.className = 'px-6 py-4 whitespace-nowrap';
                    bookCell.textContent = entry.bookTitle || '-';
                    
                    const notesCell = document.createElement('td');
                    notesCell.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400';
                    
                    if (entry.bufferUsed) {
                        notesCell.textContent = `Used ${entry.bufferUsed} buffer pages`;
                    } else if (entry.bufferAdded) {
                        notesCell.textContent = `Banked ${entry.bufferAdded} pages`;
                    } else if (entry.freePassUsed) {
                        notesCell.textContent = 'Used free pass';
                    } else {
                        notesCell.textContent = '-';
                    }
                    
                    row.appendChild(dateCell);
                    row.appendChild(pagesCell);
                    row.appendChild(bookCell);
                    row.appendChild(notesCell);
                    
                    elements.readingHistory.appendChild(row);
                });
            }

            function handleReadingSubmit(e) {
                e.preventDefault();
                
                const pagesRead = parseInt(elements.pagesReadInput.value, 10);
                const readingDate = elements.readingDateInput.value;
                const bookTitle = elements.bookTitleInput.value.trim();
                
                // Validate input
                if (pagesRead < 0) {
                    showNotification('Pages read cannot be negative.', 'error');
                    return;
                }
                
                // Check if entry for this date already exists
                const existingEntryIndex = state.readingHistory.findIndex(entry => entry.date === readingDate);
                if (existingEntryIndex !== -1) {
                    showConfirmation(
                        'Update Reading',
                        `You already have a reading entry for ${formatDate(readingDate)}. Do you want to replace it?`,
                        () => processReadingEntry(pagesRead, readingDate, bookTitle, existingEntryIndex)
                    );
                    return;
                }
                
                // Process new entry
                processReadingEntry(pagesRead, readingDate, bookTitle);
            }

            function processReadingEntry(pagesRead, readingDate, bookTitle, existingEntryIndex = -1) {
                // Create entry object
                const entry = {
                    date: readingDate,
                    pagesRead,
                    bookTitle,
                    bufferAdded: 0,
                    bufferUsed: 0,
                    freePassUsed: false
                };
                
                // Check if target was met
                const targetMet = pagesRead >= state.dailyTarget;
                
                // Calculate buffer pages to add if target exceeded
                if (targetMet) {
                    const extraPages = pagesRead - state.dailyTarget;
                    const maxBufferToAdd = Math.min(extraPages, state.maxDailyBuffer);
                    
                    if (maxBufferToAdd > 0) {
                        // Add to buffer (capped at max buffer)
                        const newBufferTotal = Math.min(state.bufferPages + maxBufferToAdd, state.maxBuffer);
                        const actualAdded = newBufferTotal - state.bufferPages;
                        
                        state.bufferPages = newBufferTotal;
                        entry.bufferAdded = actualAdded;
                        
                        if (actualAdded > 0) {
                            showNotification(`Added ${actualAdded} page${actualAdded > 1 ? 's' : ''} to your buffer!`, 'success');
                        }
                    }
                    
                    // Handle streak increment
                    incrementStreak();
                } else {
                    // Target not met, reset streak
                    resetStreak();
                    showNotification('Daily target not met. Streak reset to 0.', 'warning');
                }
                
                // Update highest pages read
                if (pagesRead > state.highestPagesRead) {
                    state.highestPagesRead = pagesRead;
                }
                
                // Add or replace entry in history
                if (existingEntryIndex !== -1) {
                    state.readingHistory[existingEntryIndex] = entry;
                } else {
                    state.readingHistory.push(entry);
                }
                
                // Update last updated date
                state.lastUpdatedDate = readingDate;
                
                // Save state and update UI
                saveState();
                updateUI();
                
                // Reset form
                elements.readingForm.reset();
                elements.readingDateInput.value = formatDateForInput(new Date());
                
                // Show confirmation
                showNotification('Reading logged successfully!', 'success');
                
                // Hide modal if it was open
                hideModal();
            }

            function handleUseBuffer() {
                if (state.bufferPages <= 0) {
                    showNotification('You have no buffer pages to use.', 'error');
                    return;
                }

                if (state.weeklyBufferUses >= state.maxWeeklyBufferUses) {
                    showNotification('You have used all your weekly buffer uses.', 'error');
                    return;
                }

                // Ask the user how many buffer pages they want to use
                const bufferPagesToUse = prompt(`How many buffer pages do you want to use? (Max: ${Math.min(state.bufferPages, state.dailyTarget)})`);
                const pagesToUse = parseInt(bufferPagesToUse, 10);

                if (isNaN(pagesToUse)) {
                    showNotification('Invalid input. Please enter a number.', 'error');
                    return;
                }

                if (pagesToUse <= 0 || pagesToUse > state.bufferPages) {
                    showNotification(`You can only use between 1 and ${state.bufferPages} buffer pages.`, 'error');
                    return;
                }

                // Check if the user has read the remaining pages
                const remainingPages = state.dailyTarget - pagesToUse;
                if (remainingPages > 0) {
                    const hasReadRemaining = confirm(`You have used ${pagesToUse} buffer pages. Have you read the remaining ${remainingPages} pages to meet your daily target?`);
                    if (!hasReadRemaining) {
                        showNotification('Daily target not met. Streak reset to 0.', 'warning');
                        resetStreak();
                        return;
                    }
                }

                // Proceed to use the buffer
                useBuffer(pagesToUse);
            }

            function useBuffer(pagesToUse) {
                const today = formatDateForInput(new Date());

                // Create entry
                const entry = {
                    date: today,
                    pagesRead: pagesToUse,
                    bookTitle: 'Buffer Used',
                    bufferAdded: 0,
                    bufferUsed: pagesToUse,
                    freePassUsed: false
                };

                // Deduct from buffer
                state.bufferPages -= pagesToUse;

                // Increment buffer usage counter
                state.weeklyBufferUses++;

                // Add to history
                const existingEntryIndex = state.readingHistory.findIndex(entry => entry.date === today);
                if (existingEntryIndex !== -1) {
                    state.readingHistory[existingEntryIndex] = entry;
                } else {
                    state.readingHistory.push(entry);
                }

                // Handle streak increment
                incrementStreak();

                // Update last updated date
                state.lastUpdatedDate = today;

                // Save and update UI
                saveState();
                updateUI();

                // Show confirmation
                showNotification(`Used ${pagesToUse} buffer pages to meet today's target!`, 'success');

                // Hide modal
                hideModal();
            }

            function handleUseFreePass() {
                if (state.freePass <= 0) {
                    showNotification('You have no free passes available.', 'error');
                    return;
                }
                
                showConfirmation(
                    'Use Free Pass',
                    'Do you want to use your free pass to maintain your streak for today?',
                    useFreePass
                );
            }

            function useFreePass() {
                const today = formatDateForInput(new Date());
                
                // Create entry
                const entry = {
                    date: today,
                    pagesRead: 0,
                    bookTitle: 'Free Pass Used',
                    bufferAdded: 0,
                    bufferUsed: 0,
                    freePassUsed: true
                };
                
                // Use free pass
                state.freePass--;
                
                // Add to history
                const existingEntryIndex = state.readingHistory.findIndex(entry => entry.date === today);
                if (existingEntryIndex !== -1) {
                    state.readingHistory[existingEntryIndex] = entry;
                } else {
                    state.readingHistory.push(entry);
                }
                
                // No streak increment, but don't reset either
                
                // Update last updated date
                state.lastUpdatedDate = today;
                
                // Save and update UI
                saveState();
                updateUI();
                
                // Show confirmation
                showNotification('Free pass used. Your streak is maintained!', 'success');
                
                // Hide modal
                hideModal();
            }

            function incrementStreak() {
                state.streakCounter++;
                
                // Check if streak cycle completed
                if (state.streakCounter >= state.streakCycle) {
                    completeStreakCycle();
                }
            }

            function completeStreakCycle() {
                // Reset streak counter
                state.streakCounter = 0;
                
                // Increment completed streaks
                state.completedStreaks++;
                
                // Increase daily target
                state.dailyTarget++;
                
                // Replenish free pass
                state.freePass = 1;
                
                // Check if 5 streaks completed (for prestige)
                checkPrestigeAvailability();
                
                // Show notification
                showNotification(`Streak cycle completed! Daily target increased to ${state.dailyTarget} pages.`, 'success');
            }

            function resetStreak() {
                state.streakCounter = 0;
            }

            function checkPrestigeAvailability() {
                // Check if prestige is available (5 completed streaks)
                if (state.completedStreaks > 0 && state.completedStreaks % 5 === 0) {
                    elements.prestigePanel.classList.remove('hidden');
                } else {
                    elements.prestigePanel.classList.add('hidden');
                }
            }

            function handlePrestige(bonusType) {
                showConfirmation(
                    'Confirm Prestige',
                    'Are you sure you want to prestige? This will reset your progress but grant you a permanent bonus.',
                    () => applyPrestigeBonus(bonusType)
                );
            }

            function applyPrestigeBonus(bonusType) {
                // Apply the selected bonus
                switch (bonusType) {
                    case 'maxDailyBuffer':
                        // Max +10 bonus
                        if (state.prestigeBonuses.maxDailyBufferBonus < 10) {
                            state.prestigeBonuses.maxDailyBufferBonus++;
                        }
                        break;
                    case 'maxBuffer':
                        // Max +25 bonus
                        if (state.prestigeBonuses.maxBufferBonus < 25) {
                            state.prestigeBonuses.maxBufferBonus += 2;
                        }
                        break;
                    case 'decayReduction':
                        // Max 25% reduction
                        if (state.prestigeBonuses.decayReductionPercent < 25) {
                            state.prestigeBonuses.decayReductionPercent += 5;
                        }
                        break;
                }
                
                // Increment prestige counter
                state.completedPrestiges++;
                
                // Reset stats
                resetStats();
                
                // Apply permanent bonuses
                applyBonuses();
                
                // Save state and update UI
                saveState();
                updateUI();
                
                // Show notification
                showNotification('Prestige complete! You\'ve received a permanent bonus.', 'success');
                
                // Hide modal
                hideModal();
            }

            function handleContinueWithoutPrestige() {
                showConfirmation(
                    'Continue Without Prestige',
                    'Are you sure you want to continue without prestiging? You\'ll receive temporary bonuses for this run only.',
                    applyNonPrestigeBonuses
                );
            }

            function applyNonPrestigeBonuses() {
                // Apply non-prestige bonuses
                state.maxWeeklyBufferUses = 3;
                state.bufferDecayCountdown = 20;
                
                // Hide prestige panel
                elements.prestigePanel.classList.add('hidden');
                
                // Save state and update UI
                saveState();
                updateUI();
                
                // Show notification
                showNotification('You\'ve received temporary bonuses for this run!', 'success');
                
                // Hide modal
                hideModal();
            }

            function resetStats() {
                // Reset most stats to default
                state.dailyTarget = 10;
                state.streakCounter = 0;
                state.streakCycle = 10;
                state.freePass = 1;
                state.bufferPages = 0;
                state.weeklyBufferUses = 0;
                state.maxWeeklyBufferUses = 2;
                state.bufferDecayCountdown = 14;
                state.completedStreaks = 0;
                
                // Keep reading history and highest pages
            }

            function applyBonuses() {
                // Apply prestige bonuses
                state.maxDailyBuffer = 5 + state.prestigeBonuses.maxDailyBufferBonus;
                state.maxBuffer = 20 + state.prestigeBonuses.maxBufferBonus;
                // Buffer decay reduction is applied when buffer decays
            }

            function checkDayChange() {
                const today = formatDateForInput(new Date());
                
                // If last updated date is null or different from today
                if (!state.lastUpdatedDate) {
                    state.lastUpdatedDate = today;
                    return;
                }
                
                // Calculate days passed
                const lastDate = new Date(state.lastUpdatedDate);
                const currentDate = new Date(today);
                const daysPassed = Math.floor((currentDate - lastDate) / (1000 * 60 * 60 * 24));
                
                if (daysPassed > 0) {
                    // Decrease buffer decay countdown
                    state.bufferDecayCountdown = Math.max(0, state.bufferDecayCountdown - daysPassed);
                    
                    // Check if buffer should decay
                    if (state.bufferDecayCountdown === 0) {
                        applyBufferDecay();
                    }
                    
                    // Check if week has reset
                    checkWeekReset();
                    
                    // Update last updated date
                    state.lastUpdatedDate = today;
                    
                    // Save state
                    saveState();
                }
            }

            function applyBufferDecay() {
                // Apply buffer decay (50% reduction)
                const decayMultiplier = 0.5 * (1 - state.prestigeBonuses.decayReductionPercent / 100);
                const decayAmount = Math.ceil(state.bufferPages * decayMultiplier);
                
                state.bufferPages = Math.max(0, state.bufferPages - decayAmount);
                
                // Reset countdown
                state.bufferDecayCountdown = 14;
                
                if (decayAmount > 0) {
                    showNotification(`Your buffer has decayed by ${decayAmount} pages.`, 'warning');
                }
            }

            function checkWeekReset() {
                const today = new Date();
                
                // Initialize week start date if not set
                if (!state.weekStartDate) {
                    state.weekStartDate = formatDateForInput(today);
                }
                
                // Calculate days since week start
                const weekStart = new Date(state.weekStartDate);
                const daysSinceWeekStart = Math.floor((today - weekStart) / (1000 * 60 * 60 * 24));
                
                // Reset weekly buffer uses if a week has passed
                if (daysSinceWeekStart >= 7) {
                    state.weeklyBufferUses = 0;
                    state.weekStartDate = formatDateForInput(today);
                }
            }

            function showConfirmation(title, message, onConfirm) {
                elements.modalTitle.textContent = title;
                elements.modalMessage.textContent = message;
                elements.modalBackdrop.classList.remove('hidden');
                
                // Set confirm action
                elements.modalConfirm.onclick = onConfirm;
            }

            function hideModal() {
                elements.modalBackdrop.classList.add('hidden');
            }

            function showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `p-4 rounded-lg shadow-lg slide-in max-w-sm text-sm`;
                
                // Set color based on type
                switch (type) {
                    case 'success':
                        notification.classList.add('bg-green-100', 'dark:bg-green-800', 'text-green-800', 'dark:text-green-100');
                        break;
                    case 'error':
                        notification.classList.add('bg-red-100', 'dark:bg-red-800', 'text-red-800', 'dark:text-red-100');
                        break;
                    case 'warning':
                        notification.classList.add('bg-yellow-100', 'dark:bg-yellow-800', 'text-yellow-800', 'dark:text-yellow-100');
                        break;
                    default:
                        notification.classList.add('bg-blue-100', 'dark:bg-blue-800', 'text-blue-800', 'dark:text-blue-100');
                }
                
                notification.textContent = message;
                
                // Add to container
                elements.notificationContainer.appendChild(notification);
                
                // Remove after 5 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(10px)';
                    notification.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                    
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 5000);
            }

            // Helper functions
            function formatDate(dateStr) {
                const date = new Date(dateStr);
                return date.toLocaleDateString();
            }

            function formatDateForInput(date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }
        });
    </script>
</body>
</html>
